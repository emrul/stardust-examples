<!DOCTYPE html>
<meta charset="utf-8">
<link rel="stylesheet" href="//stardust-vis.github.io/examples/assets/style.css" type="text/css" />
<canvas id="main-canvas"></canvas>
<div data-switch="mode">
    <button class="active" data-value="mode1">Circular</button><button data-value="mode2">Linear</button>
    <div class="fps"></div>
</div>
<div class="initializing"><p>Initializing...</p></div>
<script src="//d3js.org/d3.v3.min.js" type="text/javascript"></script>
<script src="//stardust-vis.github.io/stardust/stardust.bundle.min.js" type="text/javascript"></script>
<script src="//stardust-vis.github.io/examples/assets/utils.js" type="text/javascript"></script>
<script type="text/javascript">
    var canvas = document.getElementById("main-canvas");
    var width = 960;
    var height = 470;
    var platform = Stardust.platform("webgl-2d", canvas, width, height);

    var barSpec = Stardust.mark.compile(`
        import Triangle from P2D;

        mark Wedge(
            p1: Vector2,
            theta1: float,
            theta2: float,
            length: float,
            width: float,
            color: Color = [ 0, 0, 0, 1 ]
        ) {
            let dTheta = (theta2 - theta1) / 60;
            let dL = length / 60;
            for(i in 0..59) {
                let dThetaA = i * dTheta;
                let dThetaB = (i + 1) * dTheta;
                let thetaA = theta1 + dThetaA;
                let thetaB = theta1 + dThetaB;
                let thetaCenterA = theta1 + dThetaA / 2;
                let thetaCenterB = theta1 + dThetaB / 2;
                let dlA = dL * i;
                let dlB = dL * (i + 1);
                if(dThetaA > 1e-5 || dThetaA < -1e-5) {
                    dlA = dlA / dThetaA * 2 * sin(dThetaA / 2);
                }
                if(dThetaB > 1e-5 || dThetaB < -1e-5) {
                    dlB = dlB / dThetaB * 2 * sin(dThetaB / 2);
                }
                let pAdvA = Vector2(-sin(thetaCenterA), cos(thetaCenterA)) * dlA;
                let pAdvB = Vector2(-sin(thetaCenterB), cos(thetaCenterB)) * dlB;
                let pA = p1 + pAdvA;
                let pB = p1 + pAdvB;

                let dpA = Vector2(cos(thetaA), sin(thetaA)) * width * 0.5;
                let dpB = Vector2(cos(thetaB), sin(thetaB)) * width * 0.5;

                Triangle(pA + dpA, pB + dpB, pB - dpB, color);
                Triangle(pA + dpA, pB - dpB, pA - dpA, color);
            }
        }
        mark Bar(
            index: float,
            center: Vector2,
            vcenter: Vector2,
            radius: float,
            t1: float,
            t2: float,
            t: float,
            width: float,
            width2: float,
            color: Color = [ 0, 0, 0, 1 ]
        ) {
            let thetaA = (t1 - 6) / 12.0 * PI;
            let thetaB = (t2 - 6) / 12.0 * PI;
            let cP1 = center + Vector2(cos(thetaA), sin(thetaA)) * radius;
            let k = 1.5;
            if(t1 + t2 < 12) k = -0.5;
            let ss = 2;
            let ti = t * (1 + ss) - ss + (1 - index) * ss;
            if(ti < 0) ti = 0;
            if(ti > 1) ti = 1;
            Wedge(
                mix(cP1, vcenter + Vector2(t1 * 38, 0), ti),
                mix(thetaA, PI * k, ti),
                mix(thetaB, PI * k, ti),
                mix(radius * (thetaB - thetaA), (t2 - t1) * 38, ti),
                mix(width2, width, ti),
                color
            );
        }
    `)["Bar"];

    var bar = Stardust.mark.create(barSpec, platform);

    var colorScale = d3.scale.category10();
    var convertD3Color = (c) => {
        let m = d3.rgb(c);
        return [ m.r / 255, m.g / 255, m.b / 255, 1.0 ];
    };

    loadData("data.json", (data) => {
        // var data0 = data.slice();
        // for(var k = 0; k < 49; k++) {
        //     data = data.concat(data0);
        // }

        bar.attr("center", [ 480, 250 ] );
        bar.attr("vcenter", [ 480, 250 ]);
        bar.attr("radius", 40);
        bar.attr("t", 0);
        bar.attr("t1", d => d.start);
        bar.attr("t2", d => d.start + d.duration);
        bar.attr("color", d => convertD3Color(colorScale(d.type)));
        bar.attr("index", 0);

        let yScale = d3.scale.linear().domain([ 0, data.length - 1 ]).range([ 15, height - 15 ]);
        let h = (yScale(1) - yScale(0)) * 0.8;
        bar.attr("width", h);


        let sz = Math.sqrt((width - 15) * (height - 15) / data.length / 5);
        let grouping = Math.floor(width / sz / 2);

        bar.attr("width2", sz * 0.3);

        bar.instance((d, i) => {
             return {
                 data: d.activities,
                 attrs: {
                     index: i / (data.length - 1),
                     center: [ i % grouping * sz * 2 + sz + 4, Math.floor(i / grouping) * sz * 2 + sz + 10 ],
                     radius: sz - sz * 0.3 / 2 - 2,
                     vcenter: [ 20, yScale(i) ]
                 }
             };
        });

        bar.data(data);

        var N = 0;
        data.forEach(d => N += d.activities.length);
        console.log(N);



        function render() {
            platform.clear();
            bar.render();
        }

        render();

        switches.mode_changed = function(newValue) {
            beginTransition((t) => {
                if(newValue == "mode1")
                    bar.attr("t", 1 - t);
                if(newValue == "mode2")
                    bar.attr("t", t);
                render();
            });
        };
    });
</script>